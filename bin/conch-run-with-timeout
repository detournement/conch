#!/usr/bin/env python3
"""
Run conch-ask with a hard subprocess timeout. Used from zsh so the shell
never blocks indefinitely. Usage: conch-run-with-timeout SECONDS "request"
"""
import os
import shutil
import subprocess
import sys

def main():
    if len(sys.argv) < 3:
        print("Usage: conch-run-with-timeout SECONDS REQUEST", file=sys.stderr)
        sys.exit(1)
    try:
        timeout = int(sys.argv[1])
    except ValueError:
        print("conch-run-with-timeout: SECONDS must be an integer", file=sys.stderr)
        sys.exit(1)
    request = sys.argv[2]
    cmd = os.environ.get("CONCH_ASK_CMD", "conch-ask")
    cmd_path = shutil.which(cmd)
    if not cmd_path and os.path.sep not in cmd:
        _bin = os.path.dirname(os.path.abspath(__file__))
        candidate = os.path.join(_bin, "conch-ask")
        if os.path.isfile(candidate):
            cmd_path = candidate
    cmd_path = cmd_path or cmd
    if os.path.isfile(cmd_path) and not os.access(cmd_path, os.X_OK):
        args = [sys.executable, cmd_path, request]
    else:
        args = [cmd_path, request]
    try:
        result = subprocess.run(
            args,
            capture_output=True,
            timeout=timeout,
            env=os.environ,
        )
    except subprocess.TimeoutExpired:
        print("conch: timed out after {}s".format(timeout), file=sys.stderr)
        sys.exit(124)
    if result.stdout:
        sys.stdout.buffer.write(result.stdout)
        sys.stdout.flush()
    if result.stderr:
        sys.stderr.buffer.write(result.stderr)
    sys.exit(result.returncode)

if __name__ == "__main__":
    main()
